Το προγραμμα αυτο παιρνει απο ενα αρχειο κειμενου txt ip διευθυνσεις , αυτες τις εισαγει σε μια συναρτηση ip_prefix η οποια 
παιρνει το προθεμα prefix απο καθε ip συμφωνα με το /e (a.b.c.d/e) που εχει .
Τα προθεματα αυτα τα περνει και τα βαζει στο δεντρο.
Μετα ζητειται απο τον χρηστη να εισαγει μια ip στο δεντρο ,για να γινει χρησιμοποιειται η ιδια συναρτηση ip_prefix ομως οχι για να μετατρεψει την ip σε προθεμα 
αλλα για να μετατρεψει την δοσμενη ip σε binary ωστε να μπορεσει να την συγκρινει με τα φυλλα του δεντρου
Τελος βρισκει το μακρυτερο κοινο προθεμα (longest common prefix) συγκρινοντας καθε bit του binary αριθμου με καθε φυλλο του δεντρου αλλα και το αν 
συνεχομενα bit αντιστοιχα ειναι ιδια .


Παρακατω γινεται αναλυση της εργασιας ανα γραμμη.
Γραμμη:

22-26: 
    struct treenode: ο κομβος του δεντρου , ο οποιος περιεχει το πεδιο data στο οποιο αποθηκευονται τα δεδομενα
    δηλαδη 1 ή 0 , και τα πεδια left ,right τα οποια χρησιμευουν για να πηγαινουμε αριστερα , δεξια στο δεντρο
    
      data
     /    \
   left  right

28-30:
    δεν χρησιμοποιουνται στο προγραμμα:
        -displaytree και disp συναρτησεις ειναι υπευθυνες για την εμφανιση του δεντρου
        -treeheight

31: 
  createleaf: δημιουργει φυλλο στο δεντρο  

33:
  ip_prefix: 
    επιστρεφει το προθεμα τυπου int* 
    παραμετροι:
      int* prefix_length = μηκος προθεματος, παραμετρος η οποια επιστρεφεται στη συναρτηση
      char* input = εισαγωγη μιας ip στη συναρτηση
      char* option = επιλογη ωστε να επιστρεφει ειτε το prefix ειτε το binary

48-89:
  διαβασμα των ip απο το αρχειο routingtable.txt ανα γραμμη,
  κληση της ip_prefix για τη μετατροπη της ip apo decima dotted μορφη σε προθεμα (prefix) με παραμετρο option=="prefix"
    καθως θελουμε να επιστρεψει το προθεμα (prefix)
  και προσθεση των προθεματων (prefixes) στο δεντρο.

91-129:
  91-93:
    διαβασμα ip απο τον χρηστη ως string (input)

  95: κληση της συναρτησης ip_prefix ομως αυτη τη φορα βαζουμε την παραμετρο option="binary"
      εφοσον θελουμε να μετατρεψουμε την ip του χρηστη σε binary μορφη kai oxi σε prefix μορφη

  98-129:
    αναζητηση της ip που πληκτρολογησε ο χρηστης στο δεντρο
    ξεκινωντας απο τη ριζα: tmproot = root και υστερα αναζητωντας καθε bit της ip , αν το bit της ip =1 τοτε πηγαινε δεξια , αν οχι αριστερα 

    επισης δεν θελουμε μονο να βρουμε τα κοινα τμηματα μεταξυ της ip και των προθεματων μεσα στο δεντρο
    αλλα θελουμε επισης να εχουμε το μεγαλυτερο συνεχομενο τμημα (longest common prefix)
      η μεταβλητη temp κραταει το μετρητη της for ετσι ωστε να μπορεσει να κανει τη συγκριση temp == i-1
      η οποια ελεγχει αν συνεχομενα bit ειναι ισα
      
    Συνεπως για να κανουμε αναζητηση της ip στο δεντρο γινεται ελεγχος 
    binary[i] == tmproot->left/right->data && temp == i-1

  131-140:
    το προγραμμα διαβαζει την απαντηση του χρηστη στο αν 
    θελει να εισαγει ακομα μια ip  ή οχι ωστε το προγραμμα να 
    τερματισει